// NOTE: this solution is incomplete (still has linter errors)
// Do not edit this file, it will cause merge conflicts when I push the final solution

const SPEED = 2;
const WIDTH = 800;
const HEIGHT = 600;
const BACKGROUND_COLOR = '#000';
const PERSON_SIZE = 5;
const PERSON_COLOR = '#4CAF50';

let isRunning = false;
let animationId = null;
const people = [];
let ctx = null;

/**
 * Creates a new person object with random position and direction.
 * @returns {Object} A new person object with random position and direction.
 */
function createPerson() {
    return {
        x: Math.random() * (WIDTH - PERSON_SIZE * 2) + PERSON_SIZE,
        y: Math.random() * (HEIGHT - PERSON_SIZE * 2) + PERSON_SIZE,
        dx: (Math.random() - 0.5) * SPEED,
        dy: (Math.random() - 0.5) * SPEED,
    }
}

/**
 * Draws a person on the canvas.
 * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on.
 * @param {Object} person - The person object containing their x/y position.
 */
function drawPerson(ctx, person) {
    ctx.fillStyle = PERSON_COLOR;
    ctx.beginPath();
    ctx.arc(person.x, person.y, PERSON_SIZE, 0, 2 * Math.PI);
    ctx.fill();
}

/**
 * Draws the simulation on the canvas.
 * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on.
 */
function draw(ctx, people) {
    // Clear canvas
    ctx.fillStyle = BACKGROUND_COLOR;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // TODO: Draw all people
    for (const person of people) {
        drawPerson(ctx, person);
    }
}

/**
 * Updates the position and direction of a person.
 * @param {Object} person - The person object to update.
 */
function updatePerson(person) {
    // Update position
    person.x += person.dx;
    person.y += person.dy;

    if (person.x < PERSON_SIZE || person.x > WIDTH - PERSON_SIZE) {
        person.dx *= -1;
        person.x = Math.max(PERSON_SIZE, Math.min(person.x, WIDTH - PERSON_SIZE));
    }

    if (person.y < PERSON_SIZE || person.y > HEIGHT - PERSON_SIZE) {
        person.dy *= -1;
        person.y = Math.max(PERSON_SIZE, Math.min(person.y, HEIGHT - PERSON_SIZE));
    }

    person.dx += (Math.random() * .05*SPEED) - .025*SPEED;
    person.dy += (Math.random() * .05*SPEED) - .025*SPEED;

    const overall_speed = Math.sqrt(person.dx*person.dx + person.dy*person.dy);
    if (overall_speed > SPEED) {
        person.dx *= SPEED/overall_speed;
        person.dy *= SPEED/overall_speed;
    }
}

/**
 * Updates the position and direction of all people.
 * @param {Array} people - The array of person objects to update.
 */
function update(people) {
    // TODO: Update all of the people
    for (const person of people) {
        updatePerson(person);
    }
}

/**
 * Starts the simulation by starting the animation loop.
 */
function start() {
    if (!isRunning) {
        isRunning = true;
        document.getElementById('startBtn').disabled = true;
        document.getElementById('pauseBtn').disabled = false;
        animate();
    }
}

/**
 * Animation loop that updates and draws the simulation.
 * It uses requestAnimationFrame for smooth animations.
 */
function animate() {
    // If the simulation is running, update and draw the people
    if (isRunning) {
        update(people);
        draw(ctx, people);
        // Request the next animation frame
        animationId = requestAnimationFrame(animate);
    }
}

/**
 * Pauses the simulation by stopping the animation loop.
 */
function pause() {
    isRunning = false;
    document.getElementById('startBtn').disabled = false;
    document.getElementById('pauseBtn').disabled = true;
    if (animationId) {
        // Stop the animation (which also stops the updating)
        cancelAnimationFrame(animationId);
        animationId = null;
    }
}

/**
 * Resets the simulation by clearing the canvas and creating new people.
 */
function reset() {
    pause();

    const numPeople = +document.getElementById('numPeople').value;
    // TODO: Create all of the people after clearing the list of people
    people.length = 0;
    for (let i = 0; i < numPeople; i++) {
        people.push(createPerson());
    }

    // TODO: Draw the initial state
    draw(ctx, people);
}

/**
 * Initializes the simulation by setting up the canvas context and event listeners.
 */
document.addEventListener('DOMContentLoaded', () => {
    ctx = document.getElementById('simulationCanvas').getContext('2d');
    document.getElementById('startBtn').addEventListener('click', () => start());
    document.getElementById('pauseBtn').addEventListener('click', () => pause());
    document.getElementById('resetBtn').addEventListener('click', () => reset());
    reset();
});
